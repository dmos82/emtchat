'use client';

import React, { useEffect, useRef, useState, useCallback, useMemo } from 'react';
import { cn } from '@/lib/utils';
import { AlertCircle, Loader2, RefreshCw, Sparkles, Maximize2, Download, FileText, ZoomIn, ZoomOut, RotateCcw, Move } from 'lucide-react';
import { Button } from '@/components/ui/button';

// Diagram skeleton loader for enterprise-quality loading state
const DiagramSkeletonLoader: React.FC = () => (
  <div className="h-full w-full p-6 flex items-center justify-center">
    <div className="w-full max-w-2xl">
      {/* Flowchart skeleton */}
      <div className="flex flex-col items-center gap-4">
        {/* Top node */}
        <div
          className="h-12 w-40 rounded-lg bg-gradient-to-r from-muted via-muted-foreground/20 to-muted animate-shimmer"
          style={{ animationDelay: '0s' }}
        />
        {/* Arrow */}
        <div className="h-8 w-0.5 bg-gradient-to-b from-muted via-muted-foreground/20 to-muted animate-shimmer" />
        {/* Decision node */}
        <div
          className="h-16 w-32 rotate-45 rounded bg-gradient-to-r from-muted via-muted-foreground/20 to-muted animate-shimmer"
          style={{ animationDelay: '0.1s' }}
        />
        {/* Branch arrows */}
        <div className="flex items-start justify-center gap-24 w-full">
          <div className="flex flex-col items-center gap-4">
            <div className="h-8 w-0.5 bg-gradient-to-b from-muted via-muted-foreground/20 to-muted animate-shimmer" />
            <div
              className="h-12 w-32 rounded-lg bg-gradient-to-r from-muted via-muted-foreground/20 to-muted animate-shimmer"
              style={{ animationDelay: '0.2s' }}
            />
          </div>
          <div className="flex flex-col items-center gap-4">
            <div className="h-8 w-0.5 bg-gradient-to-b from-muted via-muted-foreground/20 to-muted animate-shimmer" />
            <div
              className="h-12 w-32 rounded-lg bg-gradient-to-r from-muted via-muted-foreground/20 to-muted animate-shimmer"
              style={{ animationDelay: '0.3s' }}
            />
          </div>
        </div>
        {/* Merge arrows */}
        <div className="flex items-start justify-center gap-24 w-full">
          <div className="h-8 w-0.5 bg-gradient-to-b from-muted via-muted-foreground/20 to-muted animate-shimmer" />
          <div className="h-8 w-0.5 bg-gradient-to-b from-muted via-muted-foreground/20 to-muted animate-shimmer" />
        </div>
        {/* Final node */}
        <div
          className="h-12 w-40 rounded-full bg-gradient-to-r from-muted via-muted-foreground/20 to-muted animate-shimmer"
          style={{ animationDelay: '0.4s' }}
        />
      </div>
    </div>
  </div>
);

interface DiagramCanvasProps {
  content: string;
  isStreaming: boolean;
  title?: string;
}

export const DiagramCanvas: React.FC<DiagramCanvasProps> = ({
  content,
  isStreaming,
  title = 'Diagram',
}) => {
  const containerRef = useRef<HTMLDivElement>(null);
  const [svgContent, setSvgContent] = useState<string>('');
  const [error, setError] = useState<string | null>(null);
  const [isRendering, setIsRendering] = useState(false);
  const lastRenderedContent = useRef<string>('');

  // Zoom and pan state
  const [scale, setScale] = useState(1);
  const [position, setPosition] = useState({ x: 0, y: 0 });
  const [isDragging, setIsDragging] = useState(false);
  const dragStart = useRef({ x: 0, y: 0 });
  const positionStart = useRef({ x: 0, y: 0 });

  const MIN_SCALE = 0.25;
  const MAX_SCALE = 4;
  const ZOOM_STEP = 0.25;

  // Open diagram in full screen browser tab
  const handleOpenFullScreen = useCallback(() => {
    if (!svgContent) return;

    const htmlContent = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title}</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      min-height: 100vh;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: flex-start;
      background: #f9fafb;
      padding: 2rem;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    h1 {
      color: #1f2937;
      font-size: 1.5rem;
      margin-bottom: 0.5rem;
      text-align: center;
    }
    .subtitle {
      color: #6b7280;
      font-size: 0.875rem;
      margin-bottom: 1.5rem;
    }
    .diagram-container {
      background: #ffffff;
      border-radius: 12px;
      padding: 2rem;
      box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
      max-width: 95vw;
      overflow: auto;
      border: 1px solid #e5e7eb;
    }
    .diagram-container svg {
      max-width: 100%;
      height: auto;
    }
    .actions {
      margin-top: 1.5rem;
      display: flex;
      gap: 1rem;
    }
    button {
      background: #ffffff;
      color: #374151;
      border: 1px solid #d1d5db;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      cursor: pointer;
      font-size: 0.875rem;
      transition: all 0.2s;
    }
    button:hover {
      background: #f3f4f6;
      border-color: #9ca3af;
    }
    @media print {
      body { background: white; padding: 1rem; }
      .diagram-container { box-shadow: none; border: none; }
      .actions { display: none; }
    }
  </style>
</head>
<body>
  <h1>${title}</h1>
  <p class="subtitle">Generated on ${new Date().toLocaleDateString()}</p>
  <div class="diagram-container">
    ${svgContent}
  </div>
  <div class="actions">
    <button onclick="window.print()">Print / Save as PDF</button>
  </div>
</body>
</html>`;

    const blob = new Blob([htmlContent], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    window.open(url, '_blank');
    setTimeout(() => URL.revokeObjectURL(url), 10000);
  }, [svgContent, title]);

  // Download as SVG file
  const handleDownloadSvg = useCallback(() => {
    if (!svgContent) return;

    const blob = new Blob([svgContent], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.svg`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  }, [svgContent, title]);

  // Download as PDF file
  const [isGeneratingPdf, setIsGeneratingPdf] = useState(false);
  const handleDownloadPdf = useCallback(async () => {
    if (!svgContent || isGeneratingPdf) return;

    setIsGeneratingPdf(true);
    try {
      // Dynamically import jsPDF and svg2pdf.js to avoid SSR issues
      const { jsPDF } = await import('jspdf');
      await import('svg2pdf.js');

      // Parse the SVG to get dimensions
      const parser = new DOMParser();
      const svgDoc = parser.parseFromString(svgContent, 'image/svg+xml');
      const svgElement = svgDoc.querySelector('svg');

      if (!svgElement) {
        throw new Error('Could not parse SVG');
      }

      // Get SVG dimensions (with fallbacks)
      let svgWidth = parseFloat(svgElement.getAttribute('width') || '800');
      let svgHeight = parseFloat(svgElement.getAttribute('height') || '600');

      // If dimensions are in other units or viewBox, try viewBox
      const viewBox = svgElement.getAttribute('viewBox');
      if (viewBox) {
        const [, , vbWidth, vbHeight] = viewBox.split(' ').map(Number);
        if (vbWidth && vbHeight) {
          svgWidth = vbWidth;
          svgHeight = vbHeight;
        }
      }

      // Calculate PDF dimensions with padding
      const padding = 40;
      const titleHeight = 60;
      const pdfWidth = svgWidth + (padding * 2);
      const pdfHeight = svgHeight + (padding * 2) + titleHeight;

      // Create PDF in landscape or portrait based on aspect ratio
      const orientation = pdfWidth > pdfHeight ? 'landscape' : 'portrait';
      const pdf = new jsPDF({
        orientation,
        unit: 'px',
        format: [pdfWidth, pdfHeight],
        hotfixes: ['px_scaling'],
      });

      // Add title
      pdf.setFontSize(24);
      pdf.setTextColor(31, 41, 55); // Dark gray
      pdf.text(title, padding, padding + 20);

      // Add subtitle with date
      pdf.setFontSize(12);
      pdf.setTextColor(107, 114, 128); // Gray
      pdf.text(`Generated on ${new Date().toLocaleDateString()}`, padding, padding + 40);

      // Create a temporary container with the SVG
      const tempContainer = document.createElement('div');
      tempContainer.innerHTML = svgContent;
      const tempSvg = tempContainer.querySelector('svg');

      if (tempSvg) {
        // Ensure SVG has explicit dimensions for svg2pdf
        tempSvg.setAttribute('width', String(svgWidth));
        tempSvg.setAttribute('height', String(svgHeight));

        // Add SVG to PDF
        await pdf.svg(tempSvg, {
          x: padding,
          y: padding + titleHeight,
          width: svgWidth,
          height: svgHeight,
        });
      }

      // Save the PDF
      const filename = `${title.replace(/[^a-z0-9]/gi, '_').toLowerCase()}.pdf`;
      pdf.save(filename);
    } catch (error) {
      console.error('Error generating PDF:', error);
      // Fallback: open full screen and let user print to PDF
      handleOpenFullScreen();
    } finally {
      setIsGeneratingPdf(false);
    }
  }, [svgContent, title, isGeneratingPdf, handleOpenFullScreen]);

  // Zoom handlers
  const handleZoomIn = useCallback(() => {
    setScale(prev => Math.min(prev + ZOOM_STEP, MAX_SCALE));
  }, []);

  const handleZoomOut = useCallback(() => {
    setScale(prev => Math.max(prev - ZOOM_STEP, MIN_SCALE));
  }, []);

  const handleResetZoom = useCallback(() => {
    setScale(1);
    setPosition({ x: 0, y: 0 });
  }, []);

  // Mouse wheel zoom (with Ctrl/Cmd key)
  const handleWheel = useCallback((e: React.WheelEvent) => {
    // Only zoom when Ctrl/Cmd is held
    if (e.ctrlKey || e.metaKey) {
      e.preventDefault();
      const delta = e.deltaY > 0 ? -ZOOM_STEP : ZOOM_STEP;
      setScale(prev => Math.min(Math.max(prev + delta, MIN_SCALE), MAX_SCALE));
    }
  }, []);

  // Pan handlers
  const handleMouseDown = useCallback((e: React.MouseEvent) => {
    // Only pan with left mouse button
    if (e.button !== 0) return;
    setIsDragging(true);
    dragStart.current = { x: e.clientX, y: e.clientY };
    positionStart.current = { ...position };
  }, [position]);

  const handleMouseMove = useCallback((e: React.MouseEvent) => {
    if (!isDragging) return;
    const dx = e.clientX - dragStart.current.x;
    const dy = e.clientY - dragStart.current.y;
    setPosition({
      x: positionStart.current.x + dx,
      y: positionStart.current.y + dy,
    });
  }, [isDragging]);

  const handleMouseUp = useCallback(() => {
    setIsDragging(false);
  }, []);

  // Reset zoom when content changes
  useEffect(() => {
    if (svgContent) {
      setScale(1);
      setPosition({ x: 0, y: 0 });
    }
  }, [svgContent]);

  const renderDiagram = useCallback(async (mermaidContent: string) => {
    if (!mermaidContent.trim() || isStreaming) return;

    // Don't re-render if content hasn't changed
    if (mermaidContent === lastRenderedContent.current) return;

    setIsRendering(true);
    setError(null);

    try {
      // Sanitize Mermaid content - fix common issues that cause parse errors
      let sanitizedContent = mermaidContent
        // Replace curly quotes with straight quotes, then escape them
        .replace(/[""]/g, '"')
        .replace(/['']/g, "'");

      // Collect subgraph names to handle references to them
      const subgraphNames: string[] = [];
      sanitizedContent.replace(/subgraph\s+([^\n\[]+)/g, (match, name) => {
        const trimmedName = name.trim();
        if (trimmedName && !trimmedName.startsWith('[')) {
          subgraphNames.push(trimmedName);
        }
        return match;
      });

      // Fix multi-word arrow targets that aren't wrapped in brackets
      // Pattern: --> or ---> followed by words without brackets
      // This handles cases like "J --> Documentation and Communication"
      let nodeCounter = 0;
      sanitizedContent = sanitizedContent.replace(
        /(-->|---)(\s*)([A-Za-z][A-Za-z0-9\s]+?)(\s*)($|\n|-->|---|;)/g,
        (match, arrow, space1, target, space2, ending) => {
          const trimmedTarget = target.trim();
          // Skip if it's a single word (valid node ID) or already has brackets
          if (!trimmedTarget.includes(' ') || trimmedTarget.includes('[') || trimmedTarget.includes('{')) {
            return match;
          }
          // Skip if it's a subgraph name - create a reference node instead
          if (subgraphNames.includes(trimmedTarget)) {
            const nodeId = `subref_${nodeCounter++}`;
            return `${arrow}${space1}${nodeId}[${trimmedTarget}]${space2}${ending}`;
          }
          // For other multi-word targets, wrap with auto-generated ID
          const nodeId = `node_${nodeCounter++}`;
          return `${arrow}${space1}${nodeId}[${trimmedTarget}]${space2}${ending}`;
        }
      );

      // Escape quotes inside node labels [...] by replacing with HTML entities
      sanitizedContent = sanitizedContent.replace(/\[([^\]]*)\]/g, (match, content) => {
        const escaped = content
          .replace(/"/g, '#quot;')
          .replace(/'/g, '#apos;');
        return `[${escaped}]`;
      });

      // Also handle content inside braces {...} for decision nodes
      sanitizedContent = sanitizedContent.replace(/\{([^}]*)\}/g, (match, content) => {
        const escaped = content
          .replace(/"/g, '#quot;')
          .replace(/'/g, '#apos;');
        return `{${escaped}}`;
      });

      // Dynamically import mermaid to avoid SSR issues
      const mermaid = (await import('mermaid')).default;

      // Initialize mermaid with explicit light theme - WYSIWYG with exported SVG
      // Force light theme regardless of app/system dark mode
      mermaid.initialize({
        startOnLoad: false,
        theme: 'base',  // 'base' gives us full control over colors via themeVariables
        darkMode: false,  // Explicitly disable dark mode detection
        securityLevel: 'loose',
        fontFamily: 'ui-sans-serif, system-ui, sans-serif',
        flowchart: {
          htmlLabels: true,
          curve: 'basis',
        },
        themeVariables: {
          // Explicit light theme colors - matches exported SVG appearance
          darkMode: false,
          background: '#ffffff',
          primaryColor: '#fbbf24',       // Amber/gold for main nodes
          primaryTextColor: '#1f2937',   // Dark gray text
          primaryBorderColor: '#d97706', // Amber border
          secondaryColor: '#fef3c7',     // Light amber
          secondaryTextColor: '#1f2937',
          secondaryBorderColor: '#d97706',
          tertiaryColor: '#f3f4f6',      // Light gray
          tertiaryTextColor: '#1f2937',
          tertiaryBorderColor: '#d1d5db',
          lineColor: '#4b5563',          // Medium gray lines
          textColor: '#1f2937',          // Default text color
          mainBkg: '#fef3c7',            // Main node background
          nodeBorder: '#d97706',
          clusterBkg: '#f9fafb',
          clusterBorder: '#d1d5db',
          titleColor: '#1f2937',
          edgeLabelBackground: '#ffffff',
          // Additional explicit colors to prevent dark mode inheritance
          noteBkgColor: '#fff5b1',
          noteTextColor: '#1f2937',
          noteBorderColor: '#d97706',
          actorBkg: '#fef3c7',
          actorBorder: '#d97706',
          actorTextColor: '#1f2937',
          actorLineColor: '#4b5563',
          signalColor: '#1f2937',
          signalTextColor: '#1f2937',
          labelBoxBkgColor: '#fef3c7',
          labelBoxBorderColor: '#d97706',
          labelTextColor: '#1f2937',
          loopTextColor: '#1f2937',
          activationBorderColor: '#d97706',
          activationBkgColor: '#fef3c7',
          sequenceNumberColor: '#ffffff',
        },
      });

      // Generate unique ID for this render
      const id = `mermaid-${Date.now()}`;

      // Render the diagram with sanitized content
      const { svg } = await mermaid.render(id, sanitizedContent);
      setSvgContent(svg);
      lastRenderedContent.current = mermaidContent;
    } catch (err) {
      console.error('Mermaid rendering error:', err);
      setError(err instanceof Error ? err.message : 'Failed to render diagram');
    } finally {
      setIsRendering(false);
    }
  }, [isStreaming]);

  // Debounced render when content changes and not streaming
  useEffect(() => {
    if (!isStreaming && content.trim()) {
      const timer = setTimeout(() => {
        renderDiagram(content);
      }, 500); // Wait for streaming to settle

      return () => clearTimeout(timer);
    }
  }, [content, isStreaming, renderDiagram]);

  const hasContent = !!content.trim();

  // Determine which layer to show - show skeleton immediately when streaming with no content
  const showSkeleton = isStreaming && !hasContent;
  const showStreamingSource = isStreaming && hasContent;
  const showError = !isStreaming && error;
  const showRendering = !isStreaming && isRendering && !error;
  const showDiagram = !isStreaming && svgContent && !error && !isRendering;
  const showEmpty = !isStreaming && !hasContent && !svgContent;

  // Always render the same DOM structure - use CSS to show/hide layers
  // IMPORTANT: Canvas always uses light theme to match exported output
  return (
    <div className="h-full w-full bg-white relative">
      {/* Layer 1: Skeleton (when streaming with no content, after delay) */}
      <div
        className={cn(
          "absolute inset-0 bg-gray-50 transition-opacity duration-150 z-10",
          showSkeleton ? "opacity-100" : "opacity-0 pointer-events-none"
        )}
      >
        <div className="flex items-center gap-2 px-6 pt-4 text-gray-600">
          <Sparkles className="h-4 w-4 animate-pulse text-amber-500" />
          <span className="text-sm animate-pulse">AI is generating diagram...</span>
        </div>
        <DiagramSkeletonLoader />
      </div>

      {/* Layer 2: Streaming source code preview */}
      <div
        className={cn(
          "absolute inset-0 overflow-auto bg-gray-50 p-4 transition-opacity duration-100",
          showStreamingSource ? "opacity-100" : "opacity-0 pointer-events-none"
        )}
      >
        <div className="mb-4 flex items-center gap-2 text-amber-600 text-sm">
          <Sparkles className="h-4 w-4 animate-pulse" />
          <span className="animate-pulse">Generating Mermaid diagram...</span>
        </div>
        <pre className="font-mono text-sm text-gray-600 whitespace-pre-wrap">
          {content}
          <span className="inline-flex items-center ml-0.5">
            <span className="relative flex h-4 w-0.5">
              <span className="animate-ping absolute inline-flex h-full w-full rounded-sm bg-amber-400 opacity-75" />
              <span className="relative inline-flex h-4 w-0.5 rounded-sm bg-amber-500" />
            </span>
          </span>
        </pre>
      </div>

      {/* Layer 3: Error state */}
      <div
        className={cn(
          "absolute inset-0 overflow-auto bg-white p-4 transition-opacity duration-100",
          showError ? "opacity-100" : "opacity-0 pointer-events-none"
        )}
      >
        <div className="mb-4 flex items-center gap-2 text-red-600">
          <AlertCircle className="h-5 w-5" />
          <span className="font-medium">Diagram Error</span>
        </div>
        <p className="text-sm text-red-500 mb-4">{error}</p>
        <div className="mb-4">
          <Button
            size="sm"
            variant="outline"
            onClick={() => renderDiagram(content)}
            className="gap-2"
          >
            <RefreshCw className="h-4 w-4" />
            Retry
          </Button>
        </div>
        <div className="border-t border-gray-200 pt-4">
          <p className="text-xs text-gray-500 mb-2">Source:</p>
          <pre className="font-mono text-xs text-gray-600 whitespace-pre-wrap bg-gray-100 p-3 rounded">
            {content}
          </pre>
        </div>
      </div>

      {/* Layer 4: Rendering state */}
      <div
        className={cn(
          "absolute inset-0 flex items-center justify-center bg-white transition-opacity duration-100",
          showRendering ? "opacity-100" : "opacity-0 pointer-events-none"
        )}
      >
        <div className="flex flex-col items-center gap-2 text-gray-500">
          <Loader2 className="h-8 w-8 animate-spin" />
          <span className="text-sm">Rendering diagram...</span>
        </div>
      </div>

      {/* Layer 5: Rendered diagram with zoom/pan */}
      <div
        className={cn(
          "absolute inset-0 flex flex-col transition-opacity duration-100",
          showDiagram ? "opacity-100" : "opacity-0 pointer-events-none"
        )}
      >
        {/* Zoomable/pannable diagram area */}
        <div
          ref={containerRef}
          className={cn(
            "flex-1 overflow-hidden bg-white relative",
            isDragging ? "cursor-grabbing" : "cursor-grab"
          )}
          onWheel={handleWheel}
          onMouseDown={handleMouseDown}
          onMouseMove={handleMouseMove}
          onMouseUp={handleMouseUp}
          onMouseLeave={handleMouseUp}
        >
          {/* Transform container for zoom/pan */}
          <div
            className="absolute inset-0 flex items-center justify-center"
            style={{
              transform: `scale(${scale}) translate(${position.x / scale}px, ${position.y / scale}px)`,
              transformOrigin: 'center center',
              transition: isDragging ? 'none' : 'transform 0.1s ease-out',
            }}
          >
            {/* Force light mode styling on SVG - ensures WYSIWYG with exported document */}
            <div
              className="mermaid-container inline-block"
              style={{
                fontSize: '14px',
                colorScheme: 'light',
              }}
              dangerouslySetInnerHTML={{ __html: svgContent }}
            />
          </div>

          {/* Zoom controls toolbar */}
          <div className="absolute bottom-4 right-4 flex items-center gap-1 bg-white/95 backdrop-blur-sm rounded-lg shadow-lg border border-gray-200 p-1 z-10">
            <Button
              size="sm"
              variant="ghost"
              onClick={handleZoomOut}
              disabled={scale <= MIN_SCALE}
              className="h-8 w-8 p-0"
              title="Zoom out"
            >
              <ZoomOut className="h-4 w-4" />
            </Button>
            <span className="text-xs font-medium text-gray-600 min-w-[3rem] text-center">
              {Math.round(scale * 100)}%
            </span>
            <Button
              size="sm"
              variant="ghost"
              onClick={handleZoomIn}
              disabled={scale >= MAX_SCALE}
              className="h-8 w-8 p-0"
              title="Zoom in"
            >
              <ZoomIn className="h-4 w-4" />
            </Button>
            <div className="w-px h-5 bg-gray-200 mx-1" />
            <Button
              size="sm"
              variant="ghost"
              onClick={handleResetZoom}
              className="h-8 w-8 p-0"
              title="Reset zoom"
            >
              <RotateCcw className="h-4 w-4" />
            </Button>
          </div>

          {/* Hint for zoom */}
          <div className="absolute bottom-4 left-4 text-xs text-gray-400 bg-white/80 px-2 py-1 rounded">
            <Move className="h-3 w-3 inline mr-1" />
            Drag to pan â€¢ Ctrl+scroll to zoom
          </div>

          <style>{`
            .mermaid-container svg {
              background: #ffffff !important;
            }
            .mermaid-container .node rect,
            .mermaid-container .node polygon,
            .mermaid-container .node circle,
            .mermaid-container .node ellipse {
              fill: #fef3c7 !important;
              stroke: #d97706 !important;
            }
            .mermaid-container .node .label,
            .mermaid-container .nodeLabel,
            .mermaid-container .label {
              color: #1f2937 !important;
              fill: #1f2937 !important;
            }
            .mermaid-container .edgeLabel {
              background-color: #ffffff !important;
              color: #1f2937 !important;
            }
            .mermaid-container .edgePath .path {
              stroke: #4b5563 !important;
            }
            .mermaid-container .cluster rect {
              fill: #f9fafb !important;
              stroke: #d1d5db !important;
            }
            .mermaid-container text {
              fill: #1f2937 !important;
            }
            .mermaid-container .flowchart-link {
              stroke: #4b5563 !important;
            }
            .mermaid-container marker path {
              fill: #4b5563 !important;
              stroke: #4b5563 !important;
            }
          `}</style>
        </div>
      </div>

      {/* Layer 6: Empty state */}
      <div
        className={cn(
          "absolute inset-0 flex items-center justify-center bg-white text-gray-400 transition-opacity duration-100",
          showEmpty ? "opacity-100" : "opacity-0 pointer-events-none"
        )}
      >
        <p className="text-sm">No diagram content</p>
      </div>
    </div>
  );
};
